{"ast":null,"code":"import React,{useState,useEffect,useRef}from'react';// Reactの必要なフックをインポート\nimport webSockets from'../styles/webSockets';// スタイルをインポート\n// WebSocketチャットコンポーネント\nimport{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const WebSocketChat=()=>{const[messages,setMessages]=useState([]);// メッセージを格納するステート\nconst[message,setMessage]=useState('');// 入力中のメッセージを保持するステート\nconst[error,setError]=useState(null);// エラーメッセージを格納するステート\nconst socketRef=useRef(null);// WebSocketインスタンスを保持するref\nconst chatBoxRef=useRef(null);// チャットボックスのスクロールを制御するref\nconst reconnectInterval=useRef(null);// 再接続のためのタイマーを保持するref\nconst reconnectAttempts=useRef(0);// 再接続試行回数をカウントするref\nconst isComposing=useRef(false);// 入力中のフラグ（IMEの状態を管理）\n// WebSocket接続関数\nconst connectWebSocket=()=>{// すでにWebSocket接続があれば閉じる\nif(socketRef.current){socketRef.current.close();}// 新しいWebSocket接続を作成\nsocketRef.current=new WebSocket('ws://localhost/ws/');// 接続が開いたときの処理\nsocketRef.current.onopen=()=>{console.log('WebSocket接続が確立しました');setError(null);// エラーステートをクリア\nreconnectAttempts.current=0;// 再接続試行回数をリセット\n};// メッセージを受信したときの処理\nsocketRef.current.onmessage=event=>{const handleMessage=function(text){let isOwn=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;// 受信したメッセージをステートに追加\nsetMessages(prevMessages=>[...prevMessages,{text,isOwn}]);setTimeout(()=>{var _chatBoxRef$current;// 新しいメッセージを表示するためにチャットボックスをスクロール\n(_chatBoxRef$current=chatBoxRef.current)===null||_chatBoxRef$current===void 0?void 0:_chatBoxRef$current.scrollTo({top:chatBoxRef.current.scrollHeight,behavior:'smooth'});},100);};// 受信したデータがBlob（ファイル）であればテキストとして読み込む\nif(event.data instanceof Blob){const reader=new FileReader();reader.onload=()=>handleMessage(reader.result);reader.readAsText(event.data);}else{// 通常のテキストメッセージとして処理\nhandleMessage(event.data);}};// エラー発生時の処理\nsocketRef.current.onerror=error=>{console.error('WebSocketエラー:',error);setError('WebSocket接続中にエラーが発生しました');// エラーステートを設定\nreconnectWebSocket();// 再接続を試みる\n};// WebSocketが閉じられたときの処理\nsocketRef.current.onclose=event=>{console.warn(`WebSocket切断 (code: ${event.code}, reason: ${event.reason})`);reconnectWebSocket();// 再接続を試みる\n};};// WebSocketの再接続処理\nconst reconnectWebSocket=()=>{// 5回の再接続試行後、エラーメッセージを表示して終了\nif(reconnectAttempts.current>=5){console.error('WebSocketの再接続に5回失敗しました');setError('サーバーへの接続が不安定です');return;}// 再接続の遅延を計算（指数バックオフ）\nconst delay=Math.min(5000,1000*2**reconnectAttempts.current);reconnectAttempts.current+=1;// 再接続試行回数を増加\nconsole.log(`WebSocket再接続を試行 (count: ${reconnectAttempts.current}, next: ${delay}ms)`);// 再接続を試みる\nclearTimeout(reconnectInterval.current);// 以前のタイマーをクリア\nreconnectInterval.current=setTimeout(()=>{connectWebSocket();// 再接続を実行\n},delay);};// コンポーネントがマウントされた時にWebSocket接続を開始\nuseEffect(()=>{connectWebSocket();// コンポーネントがアンマウントされたときにWebSocket接続を閉じる\nreturn()=>{if(socketRef.current){socketRef.current.close();}clearTimeout(reconnectInterval.current);};},[]);// メッセージ送信処理\nconst handleSendMessage=()=>{if(!message.trim())return;if(!socketRef.current||socketRef.current.readyState!==WebSocket.OPEN){setError('現在WebSocketに接続されていません');return;}// サニタイズ: 送信前にメッセージ内容をサニタイズ\nconst sanitizedMessage=message.replace(/<[^>]*>/g,'');socketRef.current.send(sanitizedMessage);// setMessages((prevMessages) => [...prevMessages, { text: sanitizedMessage, isOwn: true }]);\nsetMessage('');};const handleKeyDown=e=>{if(e.key==='Enter'&&!isComposing.current){e.preventDefault();handleSendMessage();}};return/*#__PURE__*/_jsxs(\"div\",{style:webSockets.container,children:[/*#__PURE__*/_jsx(\"h1\",{style:webSockets.header,children:\"WebSocket \\u30C1\\u30E3\\u30C3\\u30C8\"}),error&&/*#__PURE__*/_jsx(\"div\",{style:webSockets.error,children:error}),\" \",/*#__PURE__*/_jsx(\"div\",{ref:chatBoxRef,style:webSockets.chatBox,children:messages.map((msg,index)=>/*#__PURE__*/_jsx(\"div\",{style:msg.isOwn?webSockets.ownMessage:webSockets.otherMessage,children:msg.text},index))}),/*#__PURE__*/_jsxs(\"div\",{style:webSockets.inputContainer,children:[/*#__PURE__*/_jsx(\"input\",{type:\"text\",value:message,onChange:e=>setMessage(e.target.value)// 入力内容の変更を反映\n,onKeyDown:handleKeyDown// キー押下時に送信処理\n,onCompositionStart:()=>isComposing.current=true// IME入力開始時\n,onCompositionEnd:()=>isComposing.current=false// IME入力終了時\n,placeholder:\"\\u30E1\\u30C3\\u30BB\\u30FC\\u30B8\\u3092\\u5165\\u529B...\",style:webSockets.input}),/*#__PURE__*/_jsx(\"button\",{onClick:handleSendMessage,style:webSockets.button,children:\"\\u9001\\u4FE1\"})]})]});};export default WebSocketChat;","map":{"version":3,"names":["React","useState","useEffect","useRef","webSockets","jsx","_jsx","jsxs","_jsxs","WebSocketChat","messages","setMessages","message","setMessage","error","setError","socketRef","chatBoxRef","reconnectInterval","reconnectAttempts","isComposing","connectWebSocket","current","close","WebSocket","onopen","console","log","onmessage","event","handleMessage","text","isOwn","arguments","length","undefined","prevMessages","setTimeout","_chatBoxRef$current","scrollTo","top","scrollHeight","behavior","data","Blob","reader","FileReader","onload","result","readAsText","onerror","reconnectWebSocket","onclose","warn","code","reason","delay","Math","min","clearTimeout","handleSendMessage","trim","readyState","OPEN","sanitizedMessage","replace","send","handleKeyDown","e","key","preventDefault","style","container","children","header","ref","chatBox","map","msg","index","ownMessage","otherMessage","inputContainer","type","value","onChange","target","onKeyDown","onCompositionStart","onCompositionEnd","placeholder","input","onClick","button"],"sources":["/app/src/pages/WebSocketChat.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react'; // Reactの必要なフックをインポート\nimport webSockets from '../styles/webSockets'; // スタイルをインポート\n\n// WebSocketチャットコンポーネント\nconst WebSocketChat = () => {\n  const [messages, setMessages] = useState([]); // メッセージを格納するステート\n  const [message, setMessage] = useState(''); // 入力中のメッセージを保持するステート\n  const [error, setError] = useState(null); // エラーメッセージを格納するステート\n  const socketRef = useRef(null); // WebSocketインスタンスを保持するref\n  const chatBoxRef = useRef(null); // チャットボックスのスクロールを制御するref\n  const reconnectInterval = useRef(null); // 再接続のためのタイマーを保持するref\n  const reconnectAttempts = useRef(0); // 再接続試行回数をカウントするref\n  const isComposing = useRef(false); // 入力中のフラグ（IMEの状態を管理）\n\n  // WebSocket接続関数\n  const connectWebSocket = () => {\n    // すでにWebSocket接続があれば閉じる\n    if (socketRef.current) {\n      socketRef.current.close();\n    }\n\n    // 新しいWebSocket接続を作成\n    socketRef.current = new WebSocket('ws://localhost/ws/');\n\n    // 接続が開いたときの処理\n    socketRef.current.onopen = () => {\n      console.log('WebSocket接続が確立しました');\n      setError(null); // エラーステートをクリア\n      reconnectAttempts.current = 0; // 再接続試行回数をリセット\n    };\n\n    // メッセージを受信したときの処理\n    socketRef.current.onmessage = (event) => {\n      const handleMessage = (text, isOwn = false) => {\n        // 受信したメッセージをステートに追加\n        setMessages((prevMessages) => [...prevMessages, { text, isOwn }]);\n        setTimeout(() => {\n          // 新しいメッセージを表示するためにチャットボックスをスクロール\n          chatBoxRef.current?.scrollTo({ top: chatBoxRef.current.scrollHeight, behavior: 'smooth' });\n        }, 100);\n      };\n\n      // 受信したデータがBlob（ファイル）であればテキストとして読み込む\n      if (event.data instanceof Blob) {\n        const reader = new FileReader();\n        reader.onload = () => handleMessage(reader.result);\n        reader.readAsText(event.data);\n      } else {\n        // 通常のテキストメッセージとして処理\n        handleMessage(event.data);\n      }\n    };\n\n    // エラー発生時の処理\n    socketRef.current.onerror = (error) => {\n      console.error('WebSocketエラー:', error);\n      setError('WebSocket接続中にエラーが発生しました'); // エラーステートを設定\n      reconnectWebSocket(); // 再接続を試みる\n    };\n\n    // WebSocketが閉じられたときの処理\n    socketRef.current.onclose = (event) => {\n      console.warn(`WebSocket切断 (code: ${event.code}, reason: ${event.reason})`);\n      reconnectWebSocket(); // 再接続を試みる\n    };\n  };\n\n  // WebSocketの再接続処理\n  const reconnectWebSocket = () => {\n    // 5回の再接続試行後、エラーメッセージを表示して終了\n    if (reconnectAttempts.current >= 5) {\n      console.error('WebSocketの再接続に5回失敗しました');\n      setError('サーバーへの接続が不安定です');\n      return;\n    }\n\n    // 再接続の遅延を計算（指数バックオフ）\n    const delay = Math.min(5000, 1000 * 2 ** reconnectAttempts.current);\n    reconnectAttempts.current += 1; // 再接続試行回数を増加\n    console.log(`WebSocket再接続を試行 (count: ${reconnectAttempts.current}, next: ${delay}ms)`);\n\n    // 再接続を試みる\n    clearTimeout(reconnectInterval.current); // 以前のタイマーをクリア\n    reconnectInterval.current = setTimeout(() => {\n      connectWebSocket(); // 再接続を実行\n    }, delay);\n  };\n\n  // コンポーネントがマウントされた時にWebSocket接続を開始\n  useEffect(() => {\n    connectWebSocket();\n\n    // コンポーネントがアンマウントされたときにWebSocket接続を閉じる\n    return () => {\n      if (socketRef.current) {\n        socketRef.current.close();\n      }\n      clearTimeout(reconnectInterval.current);\n    };\n  }, []);\n\n  // メッセージ送信処理\n  const handleSendMessage = () => {\n      if (!message.trim()) return;\n      if (!socketRef.current || socketRef.current.readyState !== WebSocket.OPEN) {\n          setError('現在WebSocketに接続されていません');\n          return;\n      }\n\n      // サニタイズ: 送信前にメッセージ内容をサニタイズ\n      const sanitizedMessage = message.replace(/<[^>]*>/g, '');\n      socketRef.current.send(sanitizedMessage);\n\n      // setMessages((prevMessages) => [...prevMessages, { text: sanitizedMessage, isOwn: true }]);\n      setMessage('');\n  };\n\n  const handleKeyDown = (e) => {\n      if (e.key === 'Enter' && !isComposing.current) {\n          e.preventDefault();\n          handleSendMessage();\n      }\n  };\n\n  return (\n    <div style={webSockets.container}>\n      <h1 style={webSockets.header}>WebSocket チャット</h1>\n      {error && <div style={webSockets.error}>{error}</div>} {/* エラーメッセージがあれば表示 */}\n\n      <div ref={chatBoxRef} style={webSockets.chatBox}>\n        {/* 受信したメッセージを表示 */}\n        {messages.map((msg, index) => (\n          <div key={index} style={msg.isOwn ? webSockets.ownMessage : webSockets.otherMessage}>\n            {msg.text}\n          </div>\n        ))}\n      </div>\n\n      <div style={webSockets.inputContainer}>\n        {/* メッセージ入力欄 */}\n        <input\n          type=\"text\"\n          value={message}\n          onChange={(e) => setMessage(e.target.value)} // 入力内容の変更を反映\n          onKeyDown={handleKeyDown} // キー押下時に送信処理\n          onCompositionStart={() => (isComposing.current = true)} // IME入力開始時\n          onCompositionEnd={() => (isComposing.current = false)} // IME入力終了時\n          placeholder=\"メッセージを入力...\"\n          style={webSockets.input}\n        />\n        {/* 送信ボタン */}\n        <button onClick={handleSendMessage} style={webSockets.button}>送信</button>\n      </div>\n    </div>\n  );\n};\n\nexport default WebSocketChat;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}